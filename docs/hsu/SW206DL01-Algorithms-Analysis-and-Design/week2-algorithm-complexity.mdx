---
title: Week 2 - Algorithm Complexity
sidebar_label: Week 2 - Algorithm Complexity
description: Notes and diagrams for SW206DL01 - Week 2
---

# Week 2: Algorithm Complexity Analysis

## Learning Objectives

- Master asymptotic notation (Big O, Big Ω, Big Θ)
- Learn to analyze time and space complexity
- Understand best, worst, and average case analysis
- Practice complexity analysis with examples

## Asymptotic Notation

### Big O Notation - O(f(n))

Represents the **upper bound** of an algorithm's growth rate.

**Formal Definition:**
f(n) = O(g(n)) if there exist constants c > 0 and n₀ > 0 such that:
f(n) ≤ c × g(n) for all n ≥ n₀

### Big Ω Notation - Ω(f(n))

Represents the **lower bound** of an algorithm's growth rate.

**Formal Definition:**
f(n) = Ω(g(n)) if there exist constants c > 0 and n₀ > 0 such that:
f(n) ≥ c × g(n) for all n ≥ n₀

### Big Θ Notation - Θ(f(n))

Represents the **tight bound** of an algorithm's growth rate.

**Formal Definition:**
f(n) = Θ(g(n)) if there exist constants c₁, c₂ > 0 and n₀ > 0 such that:
c₁ × g(n) ≤ f(n) ≤ c₂ × g(n) for all n ≥ n₀

## Time Complexity Analysis

### Example: Nested Loops

```javascript
function nestedLoops(n) {
    let count = 0;
    for (let i = 0; i < n; i++) {        // O(n)
        for (let j = 0; j < n; j++) {    // O(n)
            count++;                     // O(1)
        }
    }
    return count;
}
```

**Total Time Complexity**: O(n²)

### Example: Sequential Statements

```javascript
function sequential(n) {
    let sum = 0;
    for (let i = 0; i < n; i++) {        // O(n)
        sum += i;
    }

    let product = 1;
    for (let j = 1; j <= n; j++) {       // O(n)
        product *= j;
    }

    return { sum, product };             // O(1)
}
```

**Total Time Complexity**: O(n)

### Example: Conditional Statements

```javascript
function findMax(arr) {
    if (arr.length === 0) return null;   // O(1)

    let max = arr[0];                    // O(1)
    for (let i = 1; i < arr.length; i++) { // O(n)
        if (arr[i] > max) {              // O(1)
            max = arr[i];                // O(1)
        }
    }
    return max;                          // O(1)
}
```

**Time Complexity**: O(n) - We consider the worst case

## Space Complexity Analysis

### Example: Array Operations

```javascript
function createArray(n) {
    let arr = [];                        // O(n) space
    for (let i = 0; i < n; i++) {        // O(n) time
        arr.push(i * i);                 // O(1)
    }
    return arr;                          // O(1)
}
```

**Time Complexity**: O(n)
**Space Complexity**: O(n)

### Example: In-Place Operations

```javascript
function reverseArray(arr) {
    let left = 0;
    let right = arr.length - 1;

    while (left < right) {               // O(n) time
        // Swap elements
        let temp = arr[left];            // O(1) space
        arr[left] = arr[right];
        arr[right] = temp;

        left++;
        right--;
    }

    return arr;
}
```

**Time Complexity**: O(n)
**Space Complexity**: O(1) - Only using constant extra space

## Best, Worst, and Average Case

### Linear Search Example

```javascript
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i;
        }
    }
    return -1;
}
```

**Best Case**: O(1) - Target is at index 0
**Worst Case**: O(n) - Target is at last index or not found
**Average Case**: O(n/2) = O(n)

### Binary Search Example

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}
```

**Best Case**: O(1) - Target is at middle element
**Worst Case**: O(log n) - Target not found or at ends
**Average Case**: O(log n)

## Common Time Complexities

| Complexity | Name | Example |
|------------|------|---------|
| O(1) | Constant | Array access, arithmetic operations |
| O(log n) | Logarithmic | Binary search, balanced BST operations |
| O(n) | Linear | Linear search, traversing array |
| O(n log n) | Linearithmic | Merge sort, quick sort, heap sort |
| O(n²) | Quadratic | Bubble sort, insertion sort, nested loops |
| O(2ⁿ) | Exponential | Recursive fibonacci, subset generation |

## Complexity Analysis Tips

1. **Focus on the dominant term** - Drop lower order terms and constants
2. **Consider worst case** unless specified otherwise
3. **Look for loops and recursion** - These often determine complexity
4. **Analyze space usage** - Don't forget about memory!

## Practice Problems

1. Analyze the time complexity of the following function:

```javascript
function mystery(n) {
    let sum = 0;
    for (let i = 1; i <= n; i *= 2) {
        for (let j = 0; j < i; j++) {
            sum++;
        }
    }
    return sum;
}
```

2. What is the space complexity of this recursive function?

```javascript
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

## Next Week

In the next lecture, we'll explore different algorithm design paradigms and start implementing various sorting algorithms.

## References

- [Big O Notation Guide](https://www.bigocheatsheet.com/)
- [Algorithm Complexity Analysis](https://visualgo.net/en)
